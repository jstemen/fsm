/*
 * This source file was generated by the Gradle 'init' task
 */
package jared.stemen.fsm;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;

import java.time.Duration;

import org.junit.jupiter.api.Test;

import jared.stemen.fsm.impl.DelayedImpl;
import jared.stemen.fsm.impl.FiniteStateMachineImpl;
import jared.stemen.fsm.impl.LinkImpl;
import jared.stemen.fsm.impl.SimpleScheduler;
import lombok.extern.slf4j.Slf4j;

@Slf4j
class DoorFSMTest {

  public enum DoorState {
    OPEN,
    CLOSED,
    LOCKED
  }

  public enum DoorEvent {
    OPEN_DOOR,
    CLOSE_DOOR,
    LOCK_DOOR,
    UNLOCK_DOOR
  }

  @Test
  void exerciseComplexDoorInteractions() throws InterruptedException {

    // Create FSM with initial state OPEN
    final FiniteStateMachine<DoorState, DoorEvent> fsm =
        new FiniteStateMachineImpl<>(DoorState.OPEN, new SimpleScheduler<DoorState, DoorEvent>());

    // Define all valid state transitions
    fsm.link(
            LinkImpl.<DoorState, DoorEvent>builder()
                .sourceState(DoorState.CLOSED)
                .event(DoorEvent.LOCK_DOOR)
                .action(() -> log.info("locking door"))
                .targetState(DoorState.LOCKED)
                .build())
        .link(
            LinkImpl.<DoorState, DoorEvent>builder()
                .sourceState(DoorState.OPEN)
                .event(DoorEvent.CLOSE_DOOR)
                .action(() -> log.info("closing door"))
                .targetState(DoorState.CLOSED)
                // delay 10 seconds, lock door if no other actions
                .delayed(
                    DelayedImpl.<DoorEvent>builder()
                        .event(DoorEvent.LOCK_DOOR)
                        .duration(Duration.ofSeconds(1))
                        .build())
                .build())
        .link(
            LinkImpl.<DoorState, DoorEvent>builder()
                .sourceState(DoorState.CLOSED)
                .event(DoorEvent.OPEN_DOOR)
                .action(() -> log.info("opening door"))
                .targetState(DoorState.OPEN)
                .build())
        // target state after time out
        .link(
            LinkImpl.<DoorState, DoorEvent>builder()
                .sourceState(DoorState.LOCKED)
                .event(DoorEvent.UNLOCK_DOOR)
                .action(() -> log.info("unlocking door"))
                .targetState(DoorState.CLOSED)
                .build());

    // Initial state verification
    assertThat(fsm.getState()).isEqualTo(DoorState.OPEN);
    log.info("Initial state: {}", fsm.getState());

    // Test invalid events for OPEN state
    assertThrows(
        IllegalStateException.class,
        () -> fsm.performEvent(DoorEvent.OPEN_DOOR),
        "Cannot open an already open door");

    assertThrows(
        IllegalStateException.class,
        () -> fsm.performEvent(DoorEvent.LOCK_DOOR),
        "Cannot lock an open door");

    assertThrows(
        IllegalStateException.class,
        () -> fsm.performEvent(DoorEvent.UNLOCK_DOOR),
        "Cannot unlock an open door");

    // OPEN -> CLOSED transition
    DoorState state = fsm.performEvent(DoorEvent.CLOSE_DOOR);
    assertThat(state).isEqualTo(DoorState.CLOSED);
    assertThat(fsm.getState()).isEqualTo(DoorState.CLOSED);
    log.info("After closing: {}", fsm.getState());

    Thread.sleep(10000);
    log.info("After 10 seconds: {}", fsm.getState());

    assertThat(fsm.getState()).isEqualTo(DoorState.LOCKED);
  }
}
